function [subInfo, status_flag] = processWithFullCoregClinic_segment(subInfo)

% Batch script for preprocessing the fMRI tests of the clinic
% (used to be the function process_withFullCoregistration.mat)

% fclose all; clear; clc;
startTime = clock;
FileVersion = 'v1.0';  %07.02.2016 - THM
status_flag = 0;

fprintf('\n\nInitializing SPM12...\n');
spm_jobman('initcfg');
spm('defaults','FMRI');

%------------------------ Setting initial parameters %--------------------------
subPath = subInfo.path;
templatePath = subInfo.parameters.templatePath;
%-------------------------------------------------------------------------------

if ~exist( fullfile( subPath, 'Logs' ) ,'file'),
    mkdir( fullfile( subPath, 'Logs' ) );
end

dateStr = [num2str(startTime(3),'%0.2d') '-' num2str(startTime(2),'%0.2d') '-' num2str(startTime(1)) ];

% creating subject name and initials
subInit = createSubInitials(subInfo);

% updating log file
logFID = fopen( fullfile( subPath, 'Logs', [ subInit '_processWithFullCoregClinic_' dateStr '.log' ] ), 'at' ); %used to be wt
fprintf( logFID, '%s (%s) - Processing with full coregistration - segmentation \n', subInfo.name, subInit);
fprintf( logFID, '-------------------------------------------------------------------\n' );
fprintf( logFID, [ 'processed with: processWithFullCoregClinic_segment.m (version ' FileVersion ')\n' ] );
fprintf( logFID, '\n%s\n', dateStr );
fprintf( logFID, '--------------\n' );
fprintf( logFID, 'Subject''s folder: %s\n\n', subPath );

try
    disp( [ 'Process script version: ' FileVersion  ] );
    
    % setting the path to the anat folder and the func folder
    analysisPath = fullfile( subPath, 'Analysis' );
    anatomyPath = fullfile( analysisPath, 'anat' );
    
    % updating log file
    fprintf( logFID, 'Segmenting %s\n', subInfo.SPGR);
    fprintf( logFID, '---------------------------------\n' );
    
    fprintf('\nProcessing segmentation on %s\n\n', [subInit '_' subInfo.SPGR]);
    
    % Settng anatomy file from subInfo
    if ~isfield(subInfo, 'SPGR')
        % let's prompt our user to select a file that would be the SPGR
        % file
        SPGRfile = uigetfile(fullfile(anatomyPath, '*.nii'), 'Select anatomy file') ;
        subInfo.SPGR = SPGRfile;
        save( fullfile(subPath, 'subInfo.mat'), 'subInfo')
    end
    
    anatomyFile = subInfo.SPGR;
    
    %%%%%%%%%%%
    % Segment %
    %%%%%%%%%%%
    % This function segments, bias corrects and spatially normalises.
    % SPM will segment the structural image using the default tissue
    % probability maps as priors.
    % SPM will create, by default, gray and white matter images and
    % bias-field corrected structral image. These can be viewed using the CheckReg facility
    % SPM will also write a spatial normalisation deformation field file
    % eg. y_sM03953_0007.nii file in the original structural directory.
    % This will be used in the next section to normalise the functional data
    
    disp('Segment');
    
    % update log file with start time of segmentation
    t = clock;
    sTime = [ num2str( t(4), '%0.2d' ) ':' num2str( t(5), '%0.2d' ) ':' num2str( round (t(6) ), '%0.2d' ) ];
    str = sprintf('%s - Start Segmentation..', sTime );
    disp( str );
    fprintf( logFID, '%s\n', str );
    
    % clear matlabbatch variable
    clear matlabbatch;
    
    % loading the matlabbatch template file
    load( fullfile(  templatePath, 'Segment_template.mat' ) );
    
    % select the subjects coregistered anatomical image (SPGR)
    matlabbatch{1}.spm.spatial.preproc.channel.vols = cellstr( strcat( [ anatomyPath '\'  anatomyFile ], ',1' ) );
    
    % SPM will segment the structural image using the default tissue
    % probability maps as priors.
    % SPM will create, by default, gray and white matter images and
    % bias-field corrected structral image.
    % SPM will also write a spatial normalisation deformation field
    % file eg. y_sM03953_0007.nii file in the original structural directory.
    % This will be used in the next section to normalise the functional data.
    spm_jobman( 'run', matlabbatch );
    
    
    %%%%%%%%%%
    % imCalc %
    %%%%%%%%%%
    % The image calculator is for performing user-specified algebraic
    % manipulations on a set of images, with the result being written out
    % as an image.
    % Skull stripping can be achieved by segmenting the anatomical scan,
    % and masking a bias corrected version (which can be generated by the
    % segmentation option) by the estimated GM, WM and CSF.
    % This masking can be done using ImCalc, by selecting the bias corrected scan
    % (m*.img), and the tissue class images (c1*.img, c2*.img and
    % c3*.img) and evaluating: i1.*((i2+i3+i4)>0.5) (0.5 is a certain
    % threshold, but we do not use it, we just do making).
    
    disp('imCalc');
    
    % update log file with start time of imcalc
    t = clock;
    sTime = [ num2str( t(4), '%0.2d' ) ':' num2str( t(5), '%0.2d' ) ':' num2str( round (t(6) ), '%0.2d' ) ];
    str = sprintf('%s - Start imCalc..', sTime );
    disp( str );
    fprintf( logFID, '%s\n', str );
    
    % clear matlabbatch variable
    clear matlabbatch;
    
    % loading the matlabbatch template file
    load( fullfile(  templatePath, 'imCalc_template.mat' ) );
    
    % HERE!!!!!!!!!
    % OVERLAY OF GM, WM, CSF
    % searching for the files that underwent segmentation (these
    % are the files with the 'c' prefix, e.g.: 'cSPGR*.nii)
    d = dir( fullfile( anatomyPath, ['c*'  anatomyFile] ) );
    files = { d.name }';
    fileNames = cellstr( strcat( [ anatomyPath '\' ], files(1:3) , ',1' ) );
    % mSPGR.nii - bias corrected scan
    fileNames{length(fileNames)+1} = [ anatomyPath '\m'  char(anatomyFile) ',1' ] ;
    
    % input - These are the images that are used by the calculator.
    % They are referred to as i1, i2, i3, etc in the order that they are specified.
    matlabbatch{1}.spm.util.imcalc.input = fileNames;
    matlabbatch{1}.spm.util.imcalc.output = ['mSPGR_skullStripped_' anatomyFile(6:end)];
    matlabbatch{1}.spm.util.imcalc.outdir = cellstr( strcat( anatomyPath));
    
    % the first (GM), second (WM) and third (CSF) images are added together and are
    % masked on the forth image (the patient's brain: mSPGR)
    matlabbatch{1}.spm.util.imcalc.expression = 'i4 .* (i1+ i2 +i3)';
    
    spm_jobman( 'run', matlabbatch );
    
    
    % clear matlabbatch variable
    clear matlabbatch;
    % loading the matlabbatch template file
    load( fullfile(  templatePath, 'imCalc_template.mat' ) );
    
    % OVERLAY OF ONLY GM
    % searching for the files that underwent segmentation (these
    % are the files with the 'c' prefix, e.g.: 'cSPGR*.nii)
    d = dir( fullfile( anatomyPath, ['c*'  anatomyFile] ) );
    files = { d.name }';
    fileNames = cellstr( strcat( [ anatomyPath '\' ], files(1) , ',1' ) );
    % mSPGR.nii - bias corrected scan
    fileNames{length(fileNames)+1} = [ anatomyPath '\m'  char(anatomyFile) ',1' ] ;
    
    % input - These are the images that are used by the calculator.
    % They are referred to as i1, i2, i3, etc in the order that they are specified.
    matlabbatch{1}.spm.util.imcalc.input = fileNames;
    matlabbatch{1}.spm.util.imcalc.output = ['mSPGR_GM_skullStripped_' anatomyFile(6:end)];
    matlabbatch{1}.spm.util.imcalc.outdir = cellstr( strcat(anatomyPath));
    
    % the first (GM) image is masked on the second image (the patient's brain: mSPGR)
    matlabbatch{1}.spm.util.imcalc.expression = 'i2 .* i1';
    
    
    spm_jobman( 'run', matlabbatch );
    
    % clear matlabbatch variable
    clear matlabbatch;
    
    % ----------------------------------------------------------------------------------------
    endTime = clock;
    totalTime = etime( endTime, startTime );
    sTime = [ num2str( startTime(4), '%0.2d' ) ':' num2str( startTime(5), '%0.2d' ) ':' num2str( round (startTime(6) ), '%0.2d' ) ];
    endTime = [ num2str( endTime(4), '%0.2d' ) ':' num2str( endTime(5), '%0.2d' ) ':' num2str( round (endTime(6) ), '%0.2d' ) ];
    totalTime = [ num2str( floor( totalTime/3600 ), '%0.2d' ) ':' num2str( floor( mod(totalTime,3600)/60 ), '%0.2d' ) ':' num2str( round ( mod(totalTime,60) ), '%0.2d' ) ];
    disp( '------------------------- Quick Summary ---------------------' );
    disp( [ 'Start time - ' sTime ] );
    disp( [ 'End   time - ' endTime ] );
    fprintf( logFID, '\n%s\n', [ 'End   time - ' endTime ] );
    disp( [ 'Total time - ' totalTime ] );
    fprintf( logFID, '%s\n', [ 'Total time - ' totalTime ] );
    status_flag = 1;
    
catch me
    endTime = clock;
    totalTime = etime( endTime, startTime );
    sTime = [ num2str( startTime(4), '%0.2d' ) ':' num2str( startTime(5), '%0.2d' ) ':' num2str( round (startTime(6) ), '%0.2d' ) ];
    endTime = [ num2str( endTime(4), '%0.2d' ) ':' num2str( endTime(5), '%0.2d' ) ':' num2str( round (endTime(6) ), '%0.2d' ) ];
    totalTime = [ num2str( floor( totalTime/3600 ), '%0.2d' ) ':' num2str( floor( mod(totalTime,3600)/60 ), '%0.2d' ) ':' num2str( round ( mod(totalTime,60) ), '%0.2d' ) ];
    disp( '------------------------- Quick Summary ---------------------' );
    disp( [ 'Start time - ' sTime ] );
    disp( [ 'Error time - ' endTime ] );
    fprintf( logFID, '\n%s\n', [ 'Error time - ' endTime ] );
    fprintf( logFID, 'Error msg - %s (line: %d)\n', me.message, me.stack(1).line);
    disp( [ 'Total time - ' totalTime ] );
    fprintf( logFID, '%s\n', [ 'Total time - ' totalTime ] );
    fclose( logFID );
    tempErrStr = lasterr;
    tempIndex = strfind( tempErrStr, '==>' );
    tempErrStr( tempIndex:tempIndex+2 ) = [];
    tempIndex = strfind( tempErrStr, 10 );
    tempErrStr( tempIndex ) = ':';
    disp( tempErrStr );
    filename = fullfile( subPath, 'Logs', [ subInit '_processWithFullCoregClinic_' dateStr '.log' ] )
    winopen(filename)
    % throw the error
    rethrow(me)
end


if (status_flag == 1)
    fprintf( logFID, '\nYAY!, Segmentation part of preprocessing ended successfully! :) \n\n' );
end

fclose( logFID );
% % let's open the log file and make sure everything is ok..
% filename = fullfile( subPath, 'Logs', [ subInit '_processWithFullCoregClinic' dateStr '.log' ] );
% winopen(filename)

end